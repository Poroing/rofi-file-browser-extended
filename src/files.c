#include <stdbool.h>
#include <stdio.h>
#include <gmodule.h>
#include <glib/gstdio.h>

#include "types.h"
#include "util.h"
#include "files.h"

/**
 * Frees the current files and initializes the file list with size 1.
 */
static void free_files ( FileBrowserFileData *fd );

/**
 * Inserts a file into the file list of FileBrowserFileData, expanding the list if necessary.
 * If the name of the file is NULL, the name is generated by the files path and depth.
 */
static void insert_file ( FBFile *fbfile, FileBrowserFileData *fd );

/**
 * Matches a base name to the specified exclude glob patterns.
 */
static bool match_glob_patterns ( const char *basename, FileBrowserFileData *fd );

/**
 * Traverse a directory recursively and add files to the list according to the file browser settings.
 */
static void file_walk ( const char *path, int depth, FileBrowserFileData *fd );

/**
 * Function used by file_walk to add files to the list.
 * Returns false if to skip the current subtree at the path, true otherwise.
 */
static inline bool file_walk_check_file ( const char *path, const char *basename, int depth, FileBrowserFileData* fd );

/**
 * Compares files alphabetically.
 */
static gint compare_files ( gconstpointer a, gconstpointer b, gpointer data );

/**
 * Compares files to sort by type (directories first, inaccessible files last).
 * Then compares files alphabetically.
 */
static gint compare_files_type ( gconstpointer a, gconstpointer b, gpointer data );

/**
 * Compares files to sort by depth.
 * Then compares files alphabetically.
 */
static gint compare_files_depth ( gconstpointer a, gconstpointer b, gpointer data );

/**
 * Compares files to sort by depth.
 * Then compares files to sort by type (directories first, inaccessible files last).
 * Then compares files alphabetically.
 */
static gint compare_files_depth_type ( gconstpointer a, gconstpointer b, gpointer data );

/**
 * Directories appear before regular files, inaccessible directories and files appear last.
 * Files of the same type are sorted alphabetically.
 */

// ================================================================================================================= //

static void free_files ( FileBrowserFileData *fd )
{
    FBFile *files = fd->files;
    for ( unsigned int i = 0; i < fd->num_files; i++ ) {
        g_free ( files[i].path );
    }
    fd->num_files = 0;
    fd->files = g_realloc ( fd->files, sizeof ( FBFile ) );
    fd->size_files = 1;
}

void destroy_files ( FileBrowserFileData *fd )
{
    free_files( fd );
    g_free ( fd->current_dir );
    g_free ( fd->files );
    g_free ( fd->up_text );
    fd->current_dir = NULL;
    fd->files = NULL;
    fd->up_text = NULL;
    for ( int i = 0; i < fd->num_exclude_patterns; i++ ) {
        g_pattern_spec_free ( fd->exclude_patterns[i] );
    }
    g_free ( fd->exclude_patterns );
    fd->num_exclude_patterns = 0;
}

static void insert_file ( FBFile *fbfile, FileBrowserFileData *fd ) {
    /* Use the path to determine the name if no name is given. */
    if ( fbfile->name == NULL ) {
        /* Determine the start position of the display name in the path. */
        int pos = strlen ( fbfile->path ) - 1;
        int levels_to_go = fbfile->depth;
        while ( levels_to_go > 0 ) {
            pos--;
            if ( fbfile->path[pos] == G_DIR_SEPARATOR ) {
                levels_to_go--;
            }
        }
        pos++;
        fbfile->name = &( fbfile->path[pos] );
    }

    /* Increase the array size if needed. */
    if ( fd->size_files <= fd->num_files ) {
        fd->size_files *= 2;
        fd->files = g_realloc ( fd->files, ( fd->size_files ) * sizeof ( FBFile ) );
    }
    fd->files[fd->num_files] = *fbfile;
    fd->num_files++;
}

void load_files ( FileBrowserFileData *fd )
{
    free_files ( fd );

    if ( ! fd->hide_parent ) {
        /* Insert the parent dir. */
        FBFile up;
        up.type = UP;
        up.name = fd->up_text;
        up.path = g_build_filename ( fd->current_dir, "..", NULL );
        up.depth = -1;
        up.icon = NULL;
        insert_file(&up, fd);
    }

    file_walk ( fd->current_dir, 0, fd );

    /* Exclude the parent dir from sorting. */
    FBFile *sort_files = fd->files;
    int num_sort_files = fd->num_files;
    if ( ! fd->hide_parent ) {
        sort_files++;
        num_sort_files--;
    }

    /* Sort all but the parent dir. */
    if ( fd->sort_by_type ) {
        if ( fd->sort_by_depth ) {
            g_qsort_with_data ( sort_files, num_sort_files, sizeof ( FBFile ), compare_files_depth_type, NULL );
        } else {
            g_qsort_with_data ( sort_files, num_sort_files, sizeof ( FBFile ), compare_files_type, NULL );
        }
    } else {
        if ( fd->sort_by_depth ) {
            g_qsort_with_data ( sort_files, num_sort_files, sizeof ( FBFile ), compare_files_depth, NULL );
        } else {
            g_qsort_with_data ( sort_files, num_sort_files, sizeof ( FBFile ), compare_files, NULL );
        }
    }
}

void change_dir ( char *path, FileBrowserFileData *pd )
{
    char* new_dir = get_canonical_abs_path ( path, pd->current_dir );
    g_free ( pd->current_dir );
    pd->current_dir = new_dir;
    g_chdir ( new_dir );
}

static bool match_glob_patterns ( const char *basename, FileBrowserFileData *fd )
{
    int len = strlen ( basename );
    for ( int i = 0; i < fd->num_exclude_patterns; i++ ) {
        if ( g_pattern_match ( fd->exclude_patterns[i], len, basename, NULL ) ) {
            return false;
        }
    }
    return true;
}

static void file_walk ( const char *path, int depth, FileBrowserFileData *fd )
{
    GDir *dir = g_dir_open ( path, 0, NULL );
    if ( dir == NULL ) {
        return;
    }

    const char *entry_basename;
    while ( ( entry_basename = g_dir_read_name ( dir ) ) != NULL ) {
        char *entry_path = g_build_filename ( path, entry_basename, NULL );
        if ( file_walk_check_file ( entry_path, entry_basename, depth + 1, fd ) ) {
            file_walk ( entry_path, depth + 1, fd );
        }
        g_free ( entry_path );
    }

    g_dir_close ( dir );
}

static inline bool file_walk_check_file ( const char *path, const char *basename, int depth, FileBrowserFileData* fd ) {
    /* Skip hidden files. */
    if ( ! fd->show_hidden && basename[0] == '.' ) {
        return false;
    }

    /* Skip excluded patterns. */
    if ( ! match_glob_patterns ( basename, fd ) ) {
        return false;
    }

    bool skip_subtree = false;
    FBFile fbfile;
    GStatBuf lstat_buf;
    GStatBuf stat_buf;

    if ( g_lstat ( path, &lstat_buf ) == 0 ) {
        if ( lstat_buf.st_mode & S_IFLNK ) {
            if ( ! fd->follow_symlinks ) {
                skip_subtree = true;
            }
            /* Check stats of the linked file in case of symlinks. */
            if ( g_stat ( path, &stat_buf ) ) {
                skip_subtree = true;
                fbfile.type = INACCESSIBLE;
                goto skip_type;
            }
        } else {
            stat_buf = lstat_buf;
        }
    } else {
        print_err("Could not stat file \"%s\".\n", path);
        return false;
    }

    /* Regular file. */
    if ( stat_buf.st_mode & S_IFREG ) {
        skip_subtree = true;
        if ( fd->only_dirs ) {
            goto skip_file;
        } else {
            fbfile.type = RFILE;
        }

    /* Regular directory. */
    } else if ( stat_buf.st_mode & S_IFDIR ) {
        if ( fd->only_files ) {
            goto skip_file;
        } else {
            fbfile.type = DIRECTORY;
        }

    /* Unknown type. */
    } else {
        skip_subtree = true;
        fbfile.type = UNKNOWN;
    }

skip_type:
    /* Construct the file. */
    fbfile.path = g_strdup ( path );
    fbfile.name = NULL;
    fbfile.depth = depth;
    fbfile.icon = NULL;

    insert_file ( &fbfile, fd );

skip_file:
    if ( skip_subtree || ( depth >= fd->depth && fd->depth != 0 ) ) {
        return false;
    } else {
        return true;
    }
}

void load_files_from_stdin ( FileBrowserFileData *fd )
{
    free_files ( fd );
    size_t current_dir_len = strlen ( fd->current_dir );

    char *buffer = NULL;
    size_t len = 0;
    ssize_t read;

    while ( ( read = getline ( &buffer, &len, stdin ) ) != -1 ) {
        /* Strip the newline. */
        buffer[read - 1] = '\0';

        FBFile fbfile;
        fbfile.type = UNKNOWN;
        fbfile.depth = 1;
        fbfile.icon = NULL;

        /* If path is absolute. */
        if ( g_path_is_absolute ( buffer ) ) {
            fbfile.path = g_strdup ( buffer );
            fbfile.name = fbfile.path;
        } else {
            fbfile.path = g_strconcat ( fd->current_dir, "/", buffer, NULL );
            fbfile.name = &fbfile.path[current_dir_len + 1];
        }

        insert_file ( &fbfile, fd );
    }

    g_free ( buffer );
}

static gint compare_files ( gconstpointer a, gconstpointer b, G_GNUC_UNUSED gpointer data )
{
    const FBFile *fa = a;
    const FBFile *fb = b;
    return g_strcmp0 ( fa->name, fb->name );
}

static gint compare_files_type ( gconstpointer a, gconstpointer b, G_GNUC_UNUSED gpointer data )
{
    const FBFile *fa = a;
    const FBFile *fb = b;
    if ( fa->type != fb->type ) {
        return fa->type - fb->type;
    } else {
        return g_strcmp0 ( fa->name, fb->name );
    }
}

static gint compare_files_depth ( gconstpointer a, gconstpointer b, G_GNUC_UNUSED gpointer data )
{
    const FBFile *fa = a;
    const FBFile *fb = b;
    if ( fa->depth != fb->depth ) {
        return fa->depth - fb->depth;
    } else {
        return g_strcmp0 ( fa->name, fb->name );
    }
}

static gint compare_files_depth_type ( gconstpointer a, gconstpointer b, G_GNUC_UNUSED gpointer data )
{
    const FBFile *fa = a;
    const FBFile *fb = b;
    if ( fa->depth != fb->depth ) {
        return fa->depth - fb->depth;
    } else if ( fa->type != fb->type ) {
        return fa->type - fb->type;
    } else {
        return g_strcmp0 ( fa->name, fb->name );
    }
}
